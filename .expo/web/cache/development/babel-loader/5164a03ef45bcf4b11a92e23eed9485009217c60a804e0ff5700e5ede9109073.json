{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.OPERATORS = void 0;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _common = require(\"@react-native-firebase/app/lib/common\");\nvar _FirestoreFieldPath = _interopRequireWildcard(require(\"./FirestoreFieldPath\"));\nvar _serialize = require(\"./utils/serialize\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nvar OPERATORS = exports.OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN'\n};\nvar INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true\n};\nvar DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\nvar FirestoreQueryModifiers = exports.default = function () {\n  function FirestoreQueryModifiers() {\n    (0, _classCallCheck2.default)(this, FirestoreQueryModifiers);\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n    this.hasInequality = false;\n    this.hasNotEqual = false;\n    this.hasArrayContains = false;\n    this.hasArrayContainsAny = false;\n    this.hasIn = false;\n    this.hasNotIn = false;\n  }\n  (0, _createClass2.default)(FirestoreQueryModifiers, [{\n    key: \"_copy\",\n    value: function _copy() {\n      var newInstance = new FirestoreQueryModifiers();\n      newInstance._limit = this._limit;\n      newInstance._limitToLast = this._limitToLast;\n      newInstance._filters = (0, _toConsumableArray2.default)(this._filters);\n      newInstance._orders = (0, _toConsumableArray2.default)(this._orders);\n      newInstance._type = this._type;\n      newInstance._startAt = this._startAt;\n      newInstance._startAfter = this._startAfter;\n      newInstance._endAt = this._endAt;\n      newInstance._endBefore = this._endBefore;\n      return newInstance;\n    }\n  }, {\n    key: \"filters\",\n    get: function get() {\n      return this._filters.map(function (f) {\n        return Object.assign({}, f, {\n          fieldPath: f.fieldPath instanceof _FirestoreFieldPath.default ? f.fieldPath._toArray() : f.fieldPath\n        });\n      });\n    }\n  }, {\n    key: \"orders\",\n    get: function get() {\n      return this._orders.map(function (f) {\n        return Object.assign({}, f, {\n          fieldPath: f.fieldPath instanceof _FirestoreFieldPath.default ? f.fieldPath._toArray() : f.fieldPath\n        });\n      });\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      var options = {};\n      if (this._limit) {\n        options.limit = this._limit;\n      }\n      if (this._limitToLast) {\n        options.limitToLast = this._limitToLast;\n      }\n      if (this._startAt) {\n        options.startAt = this._startAt;\n      }\n      if (this._startAfter) {\n        options.startAfter = this._startAfter;\n      }\n      if (this._endAt) {\n        options.endAt = this._endAt;\n      }\n      if (this._endBefore) {\n        options.endBefore = this._endBefore;\n      }\n      return options;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"setFieldsCursor\",\n    value: function setFieldsCursor(cursor, fields) {\n      this[`_${cursor}`] = (0, _serialize.buildNativeArray)(fields);\n      return this;\n    }\n  }, {\n    key: \"hasStart\",\n    value: function hasStart() {\n      return !!(this._startAt || this._startAfter);\n    }\n  }, {\n    key: \"hasEnd\",\n    value: function hasEnd() {\n      return !!(this._endAt || this._endBefore);\n    }\n  }, {\n    key: \"asCollectionGroupQuery\",\n    value: function asCollectionGroupQuery() {\n      this._type = 'collectionGroup';\n      return this;\n    }\n  }, {\n    key: \"isCollectionGroupQuery\",\n    value: function isCollectionGroupQuery() {\n      return this._type === 'collectionGroup';\n    }\n  }, {\n    key: \"isValidLimit\",\n    value: function isValidLimit(limit) {\n      return !(0, _common.isNumber)(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      this._limitToLast = undefined;\n      this._limit = _limit;\n      return this;\n    }\n  }, {\n    key: \"isValidLimitToLast\",\n    value: function isValidLimitToLast(limit) {\n      return !(0, _common.isNumber)(limit) || Math.floor(limit) !== limit || limit <= 0;\n    }\n  }, {\n    key: \"validatelimitToLast\",\n    value: function validatelimitToLast() {\n      if (this._limitToLast) {\n        if (!this._orders.length) {\n          throw new Error('firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause');\n        }\n      }\n    }\n  }, {\n    key: \"limitToLast\",\n    value: function limitToLast(_limitToLast) {\n      this._limit = undefined;\n      this._limitToLast = _limitToLast;\n      return this;\n    }\n  }, {\n    key: \"isValidOperator\",\n    value: function isValidOperator(operator) {\n      return !!OPERATORS[operator];\n    }\n  }, {\n    key: \"isEqualOperator\",\n    value: function isEqualOperator(operator) {\n      return OPERATORS[operator] === 'EQUAL';\n    }\n  }, {\n    key: \"isNotEqualOperator\",\n    value: function isNotEqualOperator(operator) {\n      return OPERATORS[operator] === 'NOT_EQUAL';\n    }\n  }, {\n    key: \"isInOperator\",\n    value: function isInOperator(operator) {\n      return OPERATORS[operator] === 'IN' || OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' || OPERATORS[operator] === 'NOT_IN';\n    }\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      var filter = {\n        fieldPath: fieldPath,\n        operator: OPERATORS[opStr],\n        value: (0, _serialize.generateNativeData)(value, true)\n      };\n      this._filters = this._filters.concat(filter);\n      return this;\n    }\n  }, {\n    key: \"filterWhere\",\n    value: function filterWhere(filter) {\n      this._filters = this._filters.concat(filter);\n      return this;\n    }\n  }, {\n    key: \"validateWhere\",\n    value: function validateWhere() {\n      if (this._filters.length > 0) {\n        this._filterCheck(this._filters);\n      }\n    }\n  }, {\n    key: \"_filterCheck\",\n    value: function _filterCheck(filters) {\n      for (var i = 0; i < filters.length; i++) {\n        var filter = filters[i];\n        if (filter.queries) {\n          this._filterCheck(filter.queries);\n          continue;\n        }\n        if (!INEQUALITY[filter.operator]) {\n          continue;\n        }\n        if (filter.operator === OPERATORS['!=']) {\n          if (this.hasNotEqual) {\n            throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n          }\n          this.hasNotEqual = true;\n        }\n        if (!this.hasInequality) {\n          this.hasInequality = filter;\n          continue;\n        }\n        if (INEQUALITY[filter.operator] && this.hasInequality) {\n          if (this.hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n            throw new Error(`Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${this.hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`);\n          }\n        }\n      }\n      for (var _i = 0; _i < filters.length; _i++) {\n        var _filter = filters[_i];\n        if (_filter.operator === OPERATORS['array-contains']) {\n          if (this.hasArrayContains) {\n            throw new Error('Invalid query. Queries only support a single array-contains filter.');\n          }\n          this.hasArrayContains = true;\n        }\n        if (_filter.operator === OPERATORS['array-contains-any']) {\n          if (this.hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use more than one 'array-contains-any' filter.\");\n          }\n          if (this.hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\");\n          }\n          this.hasArrayContainsAny = true;\n        }\n        if (_filter.operator === OPERATORS.in) {\n          if (this.hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n          }\n          this.hasIn = true;\n        }\n        if (_filter.operator === OPERATORS['not-in']) {\n          if (this.hasNotIn) {\n            throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n          }\n          if (this.hasNotEqual) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\");\n          }\n          if (this.hasIn) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n          }\n          if (this.hasArrayContainsAny) {\n            throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\");\n          }\n          this.hasNotIn = true;\n        }\n      }\n    }\n  }, {\n    key: \"isValidDirection\",\n    value: function isValidDirection(directionStr) {\n      return !!DIRECTIONS[directionStr.toLowerCase()];\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      var order = {\n        fieldPath: fieldPath,\n        direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc\n      };\n      this._orders = this._orders.concat(order);\n      return this;\n    }\n  }, {\n    key: \"validateOrderBy\",\n    value: function validateOrderBy() {\n      this._validateOrderByCheck(this._filters);\n    }\n  }, {\n    key: \"_validateOrderByCheck\",\n    value: function _validateOrderByCheck(filters) {\n      if (this._orders.length > 1) {\n        var orders = this._orders.map(function ($) {\n          return $.fieldPath._toPath();\n        });\n        var set = new Set(orders);\n        if (set.size !== orders.length) {\n          throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n        }\n      }\n      if (filters.length === 0) {\n        return;\n      }\n      for (var i = 0; i < filters.length; i++) {\n        var filter = filters[i];\n        if (filter.queries) {\n          this._validateOrderByCheck(filter.queries);\n          continue;\n        }\n        var filterFieldPath = filter.fieldPath._toPath();\n        for (var k = 0; k < this._orders.length; k++) {\n          var order = this._orders[k];\n          var orderFieldPath = order.fieldPath;\n          if (filter.operator === OPERATORS['==']) {\n            if (filterFieldPath === orderFieldPath._toPath()) {\n              throw new Error(`Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`);\n            }\n          }\n          if (filterFieldPath === _FirestoreFieldPath.DOCUMENT_ID._toPath() && orderFieldPath !== _FirestoreFieldPath.DOCUMENT_ID._toPath()) {\n            throw new Error(\"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\");\n          }\n          if (INEQUALITY[filter.operator]) {\n            if (filterFieldPath !== this._orders[0].fieldPath._toPath()) {\n              throw new Error(`Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `);\n            }\n          }\n        }\n      }\n    }\n  }]);\n  return FirestoreQueryModifiers;\n}();","map":{"version":3,"names":["_common","require","_FirestoreFieldPath","_interopRequireWildcard","_serialize","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","OPERATORS","exports","in","INEQUALITY","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","NOT_EQUAL","DIRECTIONS","asc","FirestoreQueryModifiers","_classCallCheck2","_limit","undefined","_limitToLast","_filters","_orders","_type","_startAt","_startAfter","_endAt","_endBefore","hasInequality","hasNotEqual","hasArrayContains","hasArrayContainsAny","hasIn","hasNotIn","_createClass2","value","_copy","newInstance","_toConsumableArray2","map","f","assign","fieldPath","FirestoreFieldPath","_toArray","options","limit","limitToLast","startAt","startAfter","endAt","endBefore","setFieldsCursor","cursor","fields","buildNativeArray","hasStart","hasEnd","asCollectionGroupQuery","isCollectionGroupQuery","isValidLimit","isNumber","Math","floor","isValidLimitToLast","validatelimitToLast","length","Error","isValidOperator","operator","isEqualOperator","isNotEqualOperator","isInOperator","where","opStr","filter","generateNativeData","concat","filterWhere","validateWhere","_filterCheck","filters","i","queries","_toPath","isValidDirection","directionStr","toLowerCase","orderBy","order","direction","validateOrderBy","_validateOrderByCheck","orders","$","Set","size","filterFieldPath","k","orderFieldPath","DOCUMENT_ID"],"sources":["C:/ReactNative/DemoFireBase/node_modules/@react-native-firebase/firestore/lib/FirestoreQueryModifiers.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isNumber } from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { DOCUMENT_ID } from './FirestoreFieldPath';\nimport { buildNativeArray, generateNativeData } from './utils/serialize';\n\nexport const OPERATORS = {\n  '==': 'EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '!=': 'NOT_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY',\n  'not-in': 'NOT_IN',\n  in: 'IN',\n};\n\nconst INEQUALITY = {\n  LESS_THAN: true,\n  LESS_THAN_OR_EQUAL: true,\n  GREATER_THAN: true,\n  GREATER_THAN_OR_EQUAL: true,\n  NOT_EQUAL: true,\n};\n\nconst DIRECTIONS = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING',\n};\n\nexport default class FirestoreQueryModifiers {\n  constructor() {\n    this._limit = undefined;\n    this._limitToLast = undefined;\n    this._filters = [];\n    this._orders = [];\n    this._type = 'collection';\n    // Cursors\n    this._startAt = undefined;\n    this._startAfter = undefined;\n    this._endAt = undefined;\n    this._endBefore = undefined;\n\n    // Pulled out of function to preserve their state\n    this.hasInequality = false;\n    this.hasNotEqual = false;\n    this.hasArrayContains = false;\n    this.hasArrayContainsAny = false;\n    this.hasIn = false;\n    this.hasNotIn = false;\n  }\n\n  _copy() {\n    const newInstance = new FirestoreQueryModifiers();\n    newInstance._limit = this._limit;\n    newInstance._limitToLast = this._limitToLast;\n    newInstance._filters = [...this._filters];\n    newInstance._orders = [...this._orders];\n    newInstance._type = this._type;\n    newInstance._startAt = this._startAt;\n    newInstance._startAfter = this._startAfter;\n    newInstance._endAt = this._endAt;\n    newInstance._endBefore = this._endBefore;\n    return newInstance;\n  }\n\n  get filters() {\n    return this._filters.map(f => ({\n      ...f,\n      fieldPath: f.fieldPath instanceof FirestoreFieldPath ? f.fieldPath._toArray() : f.fieldPath,\n    }));\n  }\n\n  get orders() {\n    return this._orders.map(f => ({\n      ...f,\n      fieldPath: f.fieldPath instanceof FirestoreFieldPath ? f.fieldPath._toArray() : f.fieldPath,\n    }));\n  }\n\n  get options() {\n    const options = {};\n\n    if (this._limit) {\n      options.limit = this._limit;\n    }\n\n    if (this._limitToLast) {\n      options.limitToLast = this._limitToLast;\n    }\n\n    if (this._startAt) {\n      options.startAt = this._startAt;\n    }\n    if (this._startAfter) {\n      options.startAfter = this._startAfter;\n    }\n    if (this._endAt) {\n      options.endAt = this._endAt;\n    }\n    if (this._endBefore) {\n      options.endBefore = this._endBefore;\n    }\n\n    return options;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  setFieldsCursor(cursor, fields) {\n    this[`_${cursor}`] = buildNativeArray(fields);\n    return this;\n  }\n\n  /**\n   * Options\n   */\n\n  hasStart() {\n    return !!(this._startAt || this._startAfter);\n  }\n\n  hasEnd() {\n    return !!(this._endAt || this._endBefore);\n  }\n\n  /**\n   * Collection Group Query\n   */\n\n  asCollectionGroupQuery() {\n    this._type = 'collectionGroup';\n    return this;\n  }\n\n  isCollectionGroupQuery() {\n    return this._type === 'collectionGroup';\n  }\n\n  /**\n   * Limit\n   */\n\n  isValidLimit(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  limit(limit) {\n    this._limitToLast = undefined;\n    this._limit = limit;\n    return this;\n  }\n\n  /**\n   * limitToLast\n   */\n\n  isValidLimitToLast(limit) {\n    return !isNumber(limit) || Math.floor(limit) !== limit || limit <= 0;\n  }\n\n  validatelimitToLast() {\n    if (this._limitToLast) {\n      if (!this._orders.length) {\n        throw new Error(\n          'firebase.firestore().collection().limitToLast() queries require specifying at least one firebase.firestore().collection().orderBy() clause',\n        );\n      }\n    }\n  }\n\n  limitToLast(limitToLast) {\n    this._limit = undefined;\n    this._limitToLast = limitToLast;\n    return this;\n  }\n\n  /**\n   * Filters\n   */\n\n  isValidOperator(operator) {\n    return !!OPERATORS[operator];\n  }\n\n  isEqualOperator(operator) {\n    return OPERATORS[operator] === 'EQUAL';\n  }\n\n  isNotEqualOperator(operator) {\n    return OPERATORS[operator] === 'NOT_EQUAL';\n  }\n\n  isInOperator(operator) {\n    return (\n      OPERATORS[operator] === 'IN' ||\n      OPERATORS[operator] === 'ARRAY_CONTAINS_ANY' ||\n      OPERATORS[operator] === 'NOT_IN'\n    );\n  }\n\n  where(fieldPath, opStr, value) {\n    const filter = {\n      fieldPath,\n      operator: OPERATORS[opStr],\n      value: generateNativeData(value, true),\n    };\n\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  filterWhere(filter) {\n    this._filters = this._filters.concat(filter);\n    return this;\n  }\n\n  validateWhere() {\n    if (this._filters.length > 0) {\n      this._filterCheck(this._filters);\n    }\n  }\n\n  _filterCheck(filters) {\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n\n      if (filter.queries) {\n        // Recursively check sub-queries for Filters\n        this._filterCheck(filter.queries);\n        // If it is a Filter query, skip the rest of the loop\n        continue;\n      }\n\n      // Skip if no inequality\n      if (!INEQUALITY[filter.operator]) {\n        continue;\n      }\n\n      if (filter.operator === OPERATORS['!=']) {\n        if (this.hasNotEqual) {\n          throw new Error(\"Invalid query. You cannot use more than one '!=' inequality filter.\");\n        }\n        //needs to set hasNotEqual = true  before setting first hasInequality = filter. It is used in a condition check later\n        this.hasNotEqual = true;\n      }\n\n      // Set the first inequality\n      if (!this.hasInequality) {\n        this.hasInequality = filter;\n        continue;\n      }\n\n      // Check the set value is the same as the new one\n      if (INEQUALITY[filter.operator] && this.hasInequality) {\n        if (this.hasInequality.fieldPath._toPath() !== filter.fieldPath._toPath()) {\n          throw new Error(\n            `Invalid query. All where filters with an inequality (<, <=, >, != or >=) must be on the same field. But you have inequality filters on '${this.hasInequality.fieldPath._toPath()}' and '${filter.fieldPath._toPath()}'`,\n          );\n        }\n      }\n    }\n\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n\n      if (filter.operator === OPERATORS['array-contains']) {\n        if (this.hasArrayContains) {\n          throw new Error('Invalid query. Queries only support a single array-contains filter.');\n        }\n        this.hasArrayContains = true;\n      }\n\n      if (filter.operator === OPERATORS['array-contains-any']) {\n        if (this.hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use more than one 'array-contains-any' filter.\",\n          );\n        }\n\n        if (this.hasNotIn) {\n          throw new Error(\n            \"Invalid query. You cannot use 'array-contains-any' filters with 'not-in' filters.\",\n          );\n        }\n\n        this.hasArrayContainsAny = true;\n      }\n\n      if (filter.operator === OPERATORS.in) {\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use 'in' filters with 'not-in' filters.\");\n        }\n\n        this.hasIn = true;\n      }\n\n      if (filter.operator === OPERATORS['not-in']) {\n        if (this.hasNotIn) {\n          throw new Error(\"Invalid query. You cannot use more than one 'not-in' filter.\");\n        }\n\n        if (this.hasNotEqual) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with '!=' inequality filters\",\n          );\n        }\n\n        if (this.hasIn) {\n          throw new Error(\"Invalid query. You cannot use 'not-in' filters with 'in' filters.\");\n        }\n\n        if (this.hasArrayContainsAny) {\n          throw new Error(\n            \"Invalid query. You cannot use 'not-in' filters with 'array-contains-any' filters.\",\n          );\n        }\n\n        this.hasNotIn = true;\n      }\n    }\n  }\n\n  /**\n   * Orders\n   */\n\n  isValidDirection(directionStr) {\n    return !!DIRECTIONS[directionStr.toLowerCase()];\n  }\n\n  orderBy(fieldPath, directionStr) {\n    const order = {\n      fieldPath: fieldPath,\n      direction: directionStr ? DIRECTIONS[directionStr.toLowerCase()] : DIRECTIONS.asc,\n    };\n\n    this._orders = this._orders.concat(order);\n    return this;\n  }\n\n  validateOrderBy() {\n    this._validateOrderByCheck(this._filters);\n  }\n\n  _validateOrderByCheck(filters) {\n    // Ensure order hasn't been called on the same field\n    if (this._orders.length > 1) {\n      const orders = this._orders.map($ => $.fieldPath._toPath());\n      const set = new Set(orders);\n\n      if (set.size !== orders.length) {\n        throw new Error('Invalid query. Order by clause cannot contain duplicate fields.');\n      }\n    }\n\n    // Skip if no where filters\n    if (filters.length === 0) {\n      return;\n    }\n\n    // Ensure the first order field path is equal to the inequality filter field path\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n\n      if (filter.queries) {\n        // Recursively check sub-queries for Filters\n        this._validateOrderByCheck(filter.queries);\n        // If it is a Filter query, skip the rest of the loop\n        continue;\n      }\n      const filterFieldPath = filter.fieldPath._toPath();\n\n      for (let k = 0; k < this._orders.length; k++) {\n        const order = this._orders[k];\n        const orderFieldPath = order.fieldPath;\n        if (filter.operator === OPERATORS['==']) {\n          // Any where() fieldPath parameter cannot match any orderBy() parameter when '==' operand is invoked\n          if (filterFieldPath === orderFieldPath._toPath()) {\n            throw new Error(\n              `Invalid query. Query.orderBy() parameter: ${orderFieldPath} cannot be the same as your Query.where() fieldPath parameter: ${filterFieldPath}`,\n            );\n          }\n        }\n\n        if (filterFieldPath === DOCUMENT_ID._toPath() && orderFieldPath !== DOCUMENT_ID._toPath()) {\n          throw new Error(\n            \"Invalid query. Query.where() fieldPath parameter: 'FirestoreFieldPath' cannot be used in conjunction with a different Query.orderBy() parameter\",\n          );\n        }\n\n        if (INEQUALITY[filter.operator]) {\n          // Initial orderBy() parameter has to match every where() fieldPath parameter when inequality operator is invoked\n          if (filterFieldPath !== this._orders[0].fieldPath._toPath()) {\n            throw new Error(\n              `Invalid query. Initial Query.orderBy() parameter: ${orderFieldPath} has to be the same as the Query.where() fieldPath parameter(s): ${filterFieldPath} when an inequality operator is invoked `,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}