{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractFieldPathData = extractFieldPathData;\nexports.parseSetOptions = parseSetOptions;\nexports.parseSnapshotArgs = parseSnapshotArgs;\nexports.parseUpdateArgs = parseUpdateArgs;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _common = require(\"@react-native-firebase/app/lib/common\");\nvar _FirestoreFieldPath = _interopRequireWildcard(require(\"../FirestoreFieldPath\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction extractFieldPathData(data, segments) {\n  if (!(0, _common.isObject)(data)) {\n    return undefined;\n  }\n  var pathValue = data[segments[0]];\n  if (segments.length === 1) {\n    return pathValue;\n  }\n  return extractFieldPathData(pathValue, segments.slice(1));\n}\nfunction parseUpdateArgs(args) {\n  var data = {};\n  if (args.length === 1) {\n    if (!(0, _common.isObject)(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    var _args = (0, _slicedToArray2.default)(args, 1);\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error('the update arguments must be either a single object argument, or equal numbers of key/value pairs.');\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n      if ((0, _common.isString)(key)) {\n        data[key] = value;\n      } else if (key instanceof _FirestoreFieldPath.default) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\nfunction parseSetOptions(options) {\n  var out = {};\n  if ((0, _common.isUndefined)(options)) {\n    return out;\n  }\n  if (!(0, _common.isObject)(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n  if ((0, _common.hasOwnProperty)(options, 'merge') && (0, _common.hasOwnProperty)(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n  if (!(0, _common.isUndefined)(options.merge)) {\n    if (!(0, _common.isBoolean)(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n    out.merge = options.merge;\n  }\n  if (!(0, _common.isUndefined)(options.mergeFields)) {\n    if (!(0, _common.isArray)(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n    out.mergeFields = [];\n    for (var i = 0; i < options.mergeFields.length; i++) {\n      var field = options.mergeFields[i];\n      if (!(0, _common.isString)(field) && !(field instanceof _FirestoreFieldPath.default)) {\n        throw new Error(`'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`);\n      }\n      var path = field;\n      if ((0, _common.isString)(path)) {\n        try {\n          path = (0, _FirestoreFieldPath.fromDotSeparatedString)(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n      if (field instanceof _FirestoreFieldPath.default) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n  return out;\n}\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\nfunction parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n  var NOOP = function NOOP() {};\n  var snapshotListenOptions = {};\n  var callback = NOOP;\n  var onError = NOOP;\n  var onNext = NOOP;\n  if ((0, _common.isFunction)(args[0])) {\n    if ((0, _common.isFunction)(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      callback = args[0];\n    }\n  }\n  if ((0, _common.isObject)(args[0]) && isPartialObserver(args[0])) {\n    var observer = args[0];\n    if (observer.error) {\n      onError = (0, _common.isFunction)(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = (0, _common.isFunction)(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n  if ((0, _common.isObject)(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges = args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if ((0, _common.isFunction)(args[1])) {\n      if ((0, _common.isFunction)(args[2])) {\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      var _observer = args[1];\n      if (_observer.error) {\n        onError = (0, _common.isFunction)(_observer.error) ? _observer.error.bind(_observer) : _observer.error;\n      }\n      if (_observer.next) {\n        onNext = (0, _common.isFunction)(_observer.next) ? _observer.next.bind(_observer) : _observer.next;\n      }\n    }\n  }\n  if ((0, _common.hasOwnProperty)(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!(0, _common.isBoolean)(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n  if (!(0, _common.isFunction)(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n  if (!(0, _common.isFunction)(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n  return {\n    snapshotListenOptions: snapshotListenOptions,\n    callback: callback,\n    onNext: onNext,\n    onError: onError\n  };\n}","map":{"version":3,"names":["_common","require","_FirestoreFieldPath","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","extractFieldPathData","data","segments","isObject","undefined","pathValue","length","slice","parseUpdateArgs","args","Error","_args","_slicedToArray2","i","value","isString","FirestoreFieldPath","_toPath","parseSetOptions","options","out","isUndefined","merge","isBoolean","mergeFields","isArray","field","path","fromDotSeparatedString","e","message","push","isPartialObserver","input","next","error","complete","parseSnapshotArgs","NOOP","snapshotListenOptions","callback","onError","onNext","isFunction","observer","bind","includeMetadataChanges"],"sources":["C:/ReactNative/DemoFireBase/node_modules/@react-native-firebase/firestore/lib/utils/index.js"],"sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  hasOwnProperty,\n  isArray,\n  isBoolean,\n  isFunction,\n  isObject,\n  isString,\n  isUndefined,\n} from '@react-native-firebase/app/lib/common';\nimport FirestoreFieldPath, { fromDotSeparatedString } from '../FirestoreFieldPath';\n\nexport function extractFieldPathData(data, segments) {\n  if (!isObject(data)) {\n    return undefined;\n  }\n\n  const pathValue = data[segments[0]];\n\n  if (segments.length === 1) {\n    return pathValue;\n  }\n\n  return extractFieldPathData(pathValue, segments.slice(1));\n}\n\nexport function parseUpdateArgs(args) {\n  let data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error('if using a single update argument, it must be an object.');\n    }\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(\n      'the update arguments must be either a single object argument, or equal numbers of key/value pairs.',\n    );\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FirestoreFieldPath) {\n        data[key._toPath()] = value;\n      } else {\n        throw new Error(`argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n}\n\n/**\n *\n * @param options\n */\nexport function parseSetOptions(options) {\n  const out = {};\n\n  if (isUndefined(options)) {\n    return out;\n  }\n\n  if (!isObject(options)) {\n    throw new Error(\"'options' must be an object.\");\n  }\n\n  if (hasOwnProperty(options, 'merge') && hasOwnProperty(options, 'mergeFields')) {\n    throw new Error(\"'options' must not contain both 'merge' & 'mergeFields'.\");\n  }\n\n  if (!isUndefined(options.merge)) {\n    if (!isBoolean(options.merge)) {\n      throw new Error(\"'options.merge' must be a boolean value.\");\n    }\n\n    out.merge = options.merge;\n  }\n\n  if (!isUndefined(options.mergeFields)) {\n    if (!isArray(options.mergeFields)) {\n      throw new Error(\"'options.mergeFields' must be an array.\");\n    }\n\n    out.mergeFields = [];\n\n    for (let i = 0; i < options.mergeFields.length; i++) {\n      const field = options.mergeFields[i];\n      if (!isString(field) && !(field instanceof FirestoreFieldPath)) {\n        throw new Error(\n          `'options.mergeFields' all fields must be of type string or FieldPath, but the value at index ${i} was ${typeof field}`,\n        );\n      }\n\n      let path = field;\n\n      if (isString(path)) {\n        try {\n          path = fromDotSeparatedString(field);\n        } catch (e) {\n          throw new Error(`'options.mergeFields' ${e.message}`);\n        }\n      }\n\n      if (field instanceof FirestoreFieldPath) {\n        out.mergeFields.push(field._toPath());\n      } else {\n        out.mergeFields.push(field);\n      }\n    }\n  }\n\n  return out;\n}\n\n// function buildFieldPathData(segments, value) {\n//   if (segments.length === 1) {\n//     return {\n//       [segments[0]]: value,\n//     };\n//   }\n//   return {\n//     [segments[0]]: buildFieldPathData(segments.slice(1), value),\n//   };\n// }\n\nfunction isPartialObserver(input) {\n  if (input == null) {\n    return false;\n  }\n  return input.next != null || input.error != null || input.complete != null;\n}\n\nexport function parseSnapshotArgs(args) {\n  if (args.length === 0) {\n    throw new Error('expected at least one argument.');\n  }\n\n  // Ignore onComplete as its never used\n  const NOOP = () => {};\n  const snapshotListenOptions = {};\n  let callback = NOOP;\n  let onError = NOOP;\n  let onNext = NOOP;\n\n  /**\n   * .onSnapshot(Function...\n   */\n  if (isFunction(args[0])) {\n    /**\n     * .onSnapshot((snapshot) => {}, (error) => {}\n     */\n    if (isFunction(args[1])) {\n      onNext = args[0];\n      onError = args[1];\n    } else {\n      /**\n       * .onSnapshot((snapshot, error) => {})\n       */\n      callback = args[0];\n    }\n  }\n\n  /**\n   * .onSnapshot({ complete: () => {}, error: (e) => {}, next: (snapshot) => {} })\n   */\n  if (isObject(args[0]) && isPartialObserver(args[0])) {\n    const observer = args[0];\n    if (observer.error) {\n      onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n    }\n    if (observer.next) {\n      onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n    }\n  }\n\n  /**\n   * .onSnapshot(SnapshotListenOptions, ...\n   */\n  if (isObject(args[0]) && !isPartialObserver(args[0])) {\n    snapshotListenOptions.includeMetadataChanges =\n      args[0].includeMetadataChanges == null ? false : args[0].includeMetadataChanges;\n    if (isFunction(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, Function);\n       */\n      if (isFunction(args[2])) {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (snapshot) => {}, (error) => {});\n         */\n        onNext = args[1];\n        onError = args[2];\n      } else {\n        /**\n         * .onSnapshot(SnapshotListenOptions, (s, e) => {};\n         */\n        callback = args[1];\n      }\n    } else if (isPartialObserver(args[1])) {\n      /**\n       * .onSnapshot(SnapshotListenOptions, { complete: () => {}, error: (e) => {}, next: (snapshot) => {} });\n       */\n      const observer = args[1];\n      if (observer.error) {\n        onError = isFunction(observer.error) ? observer.error.bind(observer) : observer.error;\n      }\n      if (observer.next) {\n        onNext = isFunction(observer.next) ? observer.next.bind(observer) : observer.next;\n      }\n    }\n  }\n\n  if (hasOwnProperty(snapshotListenOptions, 'includeMetadataChanges')) {\n    if (!isBoolean(snapshotListenOptions.includeMetadataChanges)) {\n      throw new Error(\"'options' SnapshotOptions.includeMetadataChanges must be a boolean value.\");\n    }\n  }\n\n  if (!isFunction(onNext)) {\n    throw new Error(\"'observer.next' or 'onNext' expected a function.\");\n  }\n\n  if (!isFunction(onError)) {\n    throw new Error(\"'observer.error' or 'onError' expected a function.\");\n  }\n\n  return { snapshotListenOptions, callback, onNext, onError };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}